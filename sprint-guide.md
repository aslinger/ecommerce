# 7-Day Sprint Plan: Cloud-Native E-Commerce Inventory & Pricing Service

This aggressive schedule is designed to complete all high-leverage tasks in Phase 4, focusing heavily on Terraform, EKS Fargate, and CI/CD to address your resume gaps (Cloud, DevOps, Polyglot) within one week.

## ðŸ“… Day 1: Infrastructure Foundation (Terraform Init & ECR)

**Goal:** Establish the VPC, SQS queue, and ECR repositories using Terraform.

| Time Allocation | Task                          | Actionable Steps                                                                                                                                                                     |
|:----------------|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **0.5 hr**      | **Setup & Project Structure** | Create a `terraform` directory. Initialize Git and your Terraform workspace.                                                                                                         |
| **2.0 hr**      | **VPC & Networking (IaC)**    | 1. Use the `terraform-aws-modules/vpc/aws` module. 2. Define a multi-AZ VPC, private subnets (for EKS/Fargate), and NAT Gateway (for outbound access). **This is the base for EKS.** |
| **1.0 hr**      | **SQS Provisioning (IaC)**    | 1. Define an `aws_sqs_queue` resource (e.g., `inventory-update-queue`). 2. Define the necessary IAM policy to allow your future EKS service accounts to send/receive messages.       |
| **0.5 hr**      | **ECR Repositories (IaC)**    | Define two `aws_ecr_repository` resources: `java-inventory-service` and `pricing-service`.                                                                                           |
| **1.0 hr**      | **Apply & Validate**          | 1. Run `terraform init` and `terraform plan`. 2. Run `terraform apply -auto-approve`. **Milestone:** VPC, SQS queue, and ECR repos are successfully created in AWS.                  |

## ðŸ“… Day 2: EKS & Security (Cluster Provisioning)

**Goal:** Deploy the serverless Kubernetes cluster (EKS Fargate) and configure necessary security roles.

| Time Allocation | Task                              | Actionable Steps                                                                                                                                                                                                                                          |
|:----------------|:----------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1.5 hr**      | **EKS Cluster Definition (IaC)**  | 1. Use the `terraform-aws-modules/eks/aws` module. 2. Configure a basic EKS cluster in the VPC created yesterday. **Crucially, enable a Fargate Profile** to run all services serverlessly.                                                               |
| **1.5 hr**      | **IRSA Configuration (Security)** | 1. Define two `aws_iam_role` resources (one for each service's Kubernetes service account). 2. Attach the SQS policy (from Day 1) to the role for the **Python/Go** consumer service. **This is key for security best practices.**                        |
| **2.0 hr**      | **Apply & Monitor**               | 1. Run `terraform apply -auto-approve`. (This step can take 15-20 minutes). 2. While waiting, use `aws eks update-kubeconfig` to configure your local `kubectl`. 3. Verify the cluster is active and you can list nodes (which will be Fargate profiles). |

## ðŸ“… Day 3: Application Logic (Polyglot & Messaging)

**Goal:** Create minimal, containerized Java and Python/Go microservices that demonstrate event-driven communication.

| Time Allocation | Task                           | Actionable Steps                                                                                                                                                                                                                                                                                                                        |
|:----------------|:-------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1.5 hr**      | **Java Producer Service**      | 1. In your existing Spring Boot app, implement a minimal `/inventory-update` endpoint. 2. Add the AWS SQS SDK dependency. 3. On call, use the SQS client to publish a simple JSON message (`{\"sku\": \"123\", \"stock\": 5}`). 4. Create a working **Dockerfile** for the Java service.                                                |
| **2.0 hr**      | **Python/Go Consumer Service** | 1. **Polyglot Gap:** Create a new project in Python (FastAPI/Boto3) or Go (Gin/AWS SDK). 2. Implement a simple polling loop or scheduled function that checks the SQS queue for messages every few seconds. 3. Log the received message to the console and **delete the message**. 4. Create a working **Dockerfile** for this service. |
| **1.5 hr**      | **Local Test & Refine**        | 1. Run both containers locally using Docker. 2. Call the Java endpoint and verify the message appears in the SQS queue via the AWS console. 3. Start the Python/Go consumer and verify it receives and deletes the message.                                                                                                             |

## ðŸ“… Day 4: Deployment Manifests & Build Specification

**Goal:** Define the Kubernetes deployment structure and the automated build process via CodeBuild.

| Time Allocation | Task                            | Actionable Steps                                                                                                                                                                                                                                                                                                                            |
|:----------------|:--------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1.5 hr**      | **Kubernetes Manifests (YAML)** | 1. Create `java-inventory-deployment.yaml` and `pricing-deployment.yaml`. 2. Include a `Service` for the Java API (for front-end access) and a `ServiceAccount` linked to the IRSA for the pricing service. 3. Include `configMap` or environment variables for SQS queue URL.                                                              |
| **1.5 hr**      | **CodeBuild Buildspec**         | Create a single `buildspec.yml` file in your repository root. This spec must: 1. Authenticate to ECR. 2. Build the **Java** Docker image. 3. Tag and push the Java image to ECR. 4. Build the **Python/Go** Docker image. 5. Tag and push the Python/Go image to ECR. **Milestone:** Manual CodeBuild test succeeds in pushing both images. |
| **2.0 hr**      | **Manual EKS Deployment Test**  | 1. Use `kubectl apply -f [manifests].yaml` to manually deploy both services to EKS. 2. Verify both services are running in Fargate pods (`kubectl get pods`). 3. Test the flow: Call the Java API, verify the Python/Go pod logs the consumed SQS message.                                                                                  |

## ðŸ“… Day 5: Automated CI/CD Pipeline

**Goal:** Automate the entire process using Terraform to provision AWS CodePipeline.

| Time Allocation | Task                                         | Actionable Steps                                                                                                                                                                                                                                                                                                                         |
|:----------------|:---------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **2.5 hr**      | **CodePipeline Definition (IaC)**            | 1. Define `aws_codepipeline` resource in Terraform. 2. **Source Stage:** Configure to pull from your Git repo (e.g., using CodeStarSourceConnection). 3. **Build Stage:** Link to the CodeBuild project created from the `buildspec.yml`. 4. **Deploy Stage:** Use the specialized `EKS` action type to apply your Kubernetes manifests. |
| **1.5 hr**      | **IAM Policies for CodePipeline (Security)** | Ensure the CodePipeline execution role has the necessary permissions to: a) Use CodeBuild. b) Access ECR. c) Interact with EKS (critical for the deployment action).                                                                                                                                                                     |
| **1.0 hr**      | **Final Apply & Test**                       | 1. Run `terraform apply -auto-approve`. 2. **Milestone:** Commit a small code change (e.g., in a README or deployment file). The commit should automatically trigger the CodePipeline, which builds both services and deploys them to EKS.                                                                                               |

## ðŸ“… Day 6: Optimization, Security & Monitoring

**Goal:** Add senior-level polish (cost-saving and production readiness) to Task 4.

| Time Allocation | Task                                         | Actionable Steps                                                                                                                                                                                                                                                                                                                                                                                  |
|:----------------|:---------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1.5 hr**      | **Cost Optimization (Kubernetes/Terraform)** | 1. Update the **Terraform EKS module** configuration to specify Fargate Profiles use **Fargate Spot capacity** where applicable for cost savings. 2. Update K8s manifests to include sensible CPU/Memory **Resource Requests and Limits**.                                                                                                                                                        |
| **1.5 hr**      | **Security Hardening (IRSA Review)**         | **Review:** Ensure the Python/Go service account has the *minimum* required SQS permissions (`receiveMessage`, `deleteMessage`) and *no* other access. Remove unnecessary default EKS/Fargate permissions if possible.                                                                                                                                                                            |
| **2.0 hr**      | **Monitoring & Alerting**                    | 1. Verify CloudWatch Logs are being captured from the Fargate Pods. 2. Define an `aws_cloudwatch_metric_alarm` in Terraform. Set the metric to monitor the `ApproximateNumberOfMessagesVisible` on your SQS queue. 3. Configure an **SNS Topic** and a simple subscriber (e.g., your email) for the alert action. **Milestone:** Automated deployment includes cost-saving and alerting features. |

## ðŸ“… Day 7: Documentation & Resume Integration

**Goal:** Translate the week's work into high-impact, quantified professional achievements.

| Time Allocation | Task                               | Actionable Steps                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|:----------------|:-----------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **3.0 hr**      | **Project Documentation (README)** | Write a detailed `README.md` for the project. **Sections must include:** 1. **Architecture Diagram** (text description, or a simple diagram). 2. **Technology Stack** (Java, Spring Boot, Python/Go, Kafka/SQS, Terraform, EKS Fargate). 3. **DevOps Maturity:** Detail the 100% IaC and automated CodePipeline process. 4. **Senior Impact:** Explain the cost strategy (Fargate Spot) and the production-ready monitoring.                                                                                                                                                                                                                                                                                   |
| **2.0 hr**      | **Resume Entry Finalization**      | Draft 2-3 powerful bullet points for your new \"Independent Consulting/Project\" section. **Focus on quantification and seniority:** 1. \"Architected and deployed a multi-language (Java, Python/Go) event-driven platform using AWS SQS and EKS Fargate, proving expertise in polyglot cloud-native design.\" 2. \"Developed a fully automated CI/CD pipeline (Terraform, AWS CodePipeline, CodeBuild) to deploy services to Kubernetes, drastically enhancing DevOps maturity and achieving cost efficiency via Fargate Spot configuration.\" 3. \"Integrated production readiness via IRSA-based least-privilege access and CloudWatch alerts on SQS backlog, addressing key security and alerting gaps.\" |

Good luck with your sprint! This highly focused plan will result in a professional-grade portfolio piece. Let me know which language you prefer for the Dynamic Pricing Microservice (Python or Go), and I can start generating the boilerplate Terraform files for **Day 1**.
